import global$1 from './global.js';
import functionBindContext from './function-bind-context.js';
import functionCall from './function-call.js';
import toObject$1 from './to-object.js';
import callWithSafeIterationClosing$1 from './call-with-safe-iteration-closing.js';
import isArrayIteratorMethod$1 from './is-array-iterator-method.js';
import isConstructor$1 from './is-constructor.js';
import lengthOfArrayLike$1 from './length-of-array-like.js';
import createProperty$1 from './create-property.js';
import getIterator$1 from './get-iterator.js';
import getIteratorMethod$1 from './get-iterator-method.js';

var global = global$1;
var bind = functionBindContext;
var call = functionCall;
var toObject = toObject$1;
var callWithSafeIterationClosing = callWithSafeIterationClosing$1;
var isArrayIteratorMethod = isArrayIteratorMethod$1;
var isConstructor = isConstructor$1;
var lengthOfArrayLike = lengthOfArrayLike$1;
var createProperty = createProperty$1;
var getIterator = getIterator$1;
var getIteratorMethod = getIteratorMethod$1;
var Array = global.Array; // `Array.from` method implementation
// https://tc39.es/ecma262/#sec-array.from

var arrayFrom = function from(arrayLike
/* , mapfn = undefined, thisArg = undefined */
) {
  var O = toObject(arrayLike);
  var IS_CONSTRUCTOR = isConstructor(this);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined);
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length, result, step, iterator, next, value; // if the target is not iterable or it's an array with the default iterator - use a simple case

  if (iteratorMethod && !(this == Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = getIterator(O, iteratorMethod);
    next = iterator.next;
    result = IS_CONSTRUCTOR ? new this() : [];

    for (; !(step = call(next, iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty(result, index, value);
    }
  } else {
    length = lengthOfArrayLike(O);
    result = IS_CONSTRUCTOR ? new this(length) : Array(length);

    for (; length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty(result, index, value);
    }
  }

  result.length = index;
  return result;
};

export { arrayFrom as default };

import functionBindContext from './function-bind-context.js';
import functionCall from './function-call.js';
import aConstructor$1 from './a-constructor.js';
import toObject$1 from './to-object.js';
import lengthOfArrayLike$1 from './length-of-array-like.js';
import getIterator$1 from './get-iterator.js';
import getIteratorMethod$1 from './get-iterator-method.js';
import isArrayIteratorMethod$1 from './is-array-iterator-method.js';
import arrayBufferViewCore from './array-buffer-view-core.js';

var bind = functionBindContext;
var call = functionCall;
var aConstructor = aConstructor$1;
var toObject = toObject$1;
var lengthOfArrayLike = lengthOfArrayLike$1;
var getIterator = getIterator$1;
var getIteratorMethod = getIteratorMethod$1;
var isArrayIteratorMethod = isArrayIteratorMethod$1;
var aTypedArrayConstructor = arrayBufferViewCore.aTypedArrayConstructor;

var typedArrayFrom = function from(source
/* , mapfn, thisArg */
) {
  var C = aConstructor(this);
  var O = toObject(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var i, length, result, step, iterator, next;

  if (iteratorMethod && !isArrayIteratorMethod(iteratorMethod)) {
    iterator = getIterator(O, iteratorMethod);
    next = iterator.next;
    O = [];

    while (!(step = call(next, iterator)).done) {
      O.push(step.value);
    }
  }

  if (mapping && argumentsLength > 2) {
    mapfn = bind(mapfn, arguments[2]);
  }

  length = lengthOfArrayLike(O);
  result = new (aTypedArrayConstructor(C))(length);

  for (i = 0; length > i; i++) {
    result[i] = mapping ? mapfn(O[i], i) : O[i];
  }

  return result;
};

export { typedArrayFrom as default };

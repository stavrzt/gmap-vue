import functionCall from '../internals/function-call.js';
import fixRegexpWellKnownSymbolLogic from '../internals/fix-regexp-well-known-symbol-logic.js';
import anObject$1 from '../internals/an-object.js';
import requireObjectCoercible$1 from '../internals/require-object-coercible.js';
import sameValue$1 from '../internals/same-value.js';
import toString$1 from '../internals/to-string.js';
import getMethod$1 from '../internals/get-method.js';
import regexpExecAbstract from '../internals/regexp-exec-abstract.js';

var call = functionCall;
var fixRegExpWellKnownSymbolLogic = fixRegexpWellKnownSymbolLogic;
var anObject = anObject$1;
var requireObjectCoercible = requireObjectCoercible$1;
var sameValue = sameValue$1;
var toString = toString$1;
var getMethod = getMethod$1;
var regExpExec = regexpExecAbstract; // @@search logic

fixRegExpWellKnownSymbolLogic('search', function (SEARCH, nativeSearch, maybeCallNative) {
  return [// `String.prototype.search` method
  // https://tc39.es/ecma262/#sec-string.prototype.search
  function search(regexp) {
    var O = requireObjectCoercible(this);
    var searcher = regexp == undefined ? undefined : getMethod(regexp, SEARCH);
    return searcher ? call(searcher, regexp, O) : new RegExp(regexp)[SEARCH](toString(O));
  }, // `RegExp.prototype[@@search]` method
  // https://tc39.es/ecma262/#sec-regexp.prototype-@@search
  function (string) {
    var rx = anObject(this);
    var S = toString(string);
    var res = maybeCallNative(nativeSearch, rx, S);
    if (res.done) return res.value;
    var previousLastIndex = rx.lastIndex;
    if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
    var result = regExpExec(rx, S);
    if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
    return result === null ? -1 : result.index;
  }];
});
